{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dist/ng-stats.min.js","webpack:///webpack/bootstrap eccbefdad40d7144684b","webpack:///./index.js","webpack:///external \"angular\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","hijackDigest","digestIsHijacked","scopePrototype","Object","getPrototypeOf","getRootScope","oldDigest","$digest","start","timerNow","apply","arguments","diff","updateData","getWatcherCount","isChromeApp","chrome","storage","local","autoload","options","window","self","angular","showAngularStats","setTimeout","opts","track","thingToTrack","listenerCollection","diffOnly","capThingToTrack","charAt","toUpperCase","slice","returnData","tracked","length","push","log","thingToLog","capThingToLog","last","color","colorLog","console","digestTimeThreshold","addDataToCanvas","watchCount","digestLength","averageDigest","lastDigestLength","lastWatchCount","nullOrUndef","$text","text","toFixed","css","ctx","cvs","getContext","noDigestSteps","fillStyle","fillRect","graphSz","width","height","Math","max","shiftLeft","state","active","imageData","getImageData","putImageData","undefined","listeners","current","$el","remove","sessionStorage","removeItem","autoloadKey","localStorage","position","extend","htmlId","trackDigest","trackWatches","logDigest","logWatches","styles","background","borderBottom","borderRight","fontFamily","zIndex","textAlign","top","indexOf","bottom","right","left","setItem","JSON","stringify","Error","bodyEl","element","document","body","append","find","attr","ngStatsAddToCanvas","$rootScope","$$phase","scopeEl","querySelector","scope","$root","clearTimeout","watchCountTimeout","now","lastWatchCountRun","getWatcherCountForScope","getWatcherCountForElement","startingScope","getClosestChildScope","getWatchersFromScope","$$watchers","forEach","listener","item","count","iterateScopes","childScope","currentScope","fn","_makeScopeReference","ret","iterateChildren","iterateSiblings","$$nextSibling","$$childHead","getScopeById","myScope","$id","_isScopeId","defineProperty","value","_angular","_angular2","version","performance","Date","autoloadOptions","parse","directive","findRootOfElement","el","parent","parentElement","index","watchCountRoot","onDigestLengthUpdate","onWatchCountUpdate","link","attrs","setupDigestLengthElement","hasOwnProperty","digestEl","directiveIndex","dirDigestNode","setupWatchCountElement","watchCountEl","rootParent","addWatchCountListener","addDigestLengthListener","destroyListeners","$on"],"mappings":"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","file":"dist/ng-stats.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"showAngularStats\"] = factory(require(\"angular\"));\n\telse\n\t\troot[\"showAngularStats\"] = factory(root[\"angular\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","//! ng-stats version 2.3.1 built with ♥ by Kent C. Dodds <kent@doddsfamily.us> (http://kent.doddsfamily.us), Viper Bailey <jinxidoru@gmail.com> (http://jinxidoru.blogspot.com) (ó ì_í)=óò=(ì_í ò)\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"showAngularStats\"] = factory(require(\"angular\"));\n\telse\n\t\troot[\"showAngularStats\"] = factory(root[\"angular\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* eslint no-console:0 */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar angular = _angular2['default'];\n\t\n\t/* istanbul ignore next */\n\tif (!angular.version) {\n\t  // we're doing this because some versions\n\t  // of angular don't expose itself correctly\n\t  angular = window.angular;\n\t}\n\t\n\texports['default'] = showAngularStats;\n\t\n\tvar autoloadKey = 'showAngularStats_autoload';\n\tvar current = null;\n\t// define the timer function to use based upon whether or not 'performance is available'\n\tvar timerNow = window.self.performance && window.self.performance.now ? function () {\n\t  return window.self.performance.now();\n\t} : function () {\n\t  return Date.now();\n\t};\n\t\n\tvar lastWatchCountRun = timerNow();\n\tvar watchCountTimeout = null;\n\tvar lastWatchCount = getWatcherCount() || 0;\n\tvar lastDigestLength = 0;\n\t\n\tvar $rootScope;\n\t\n\tvar digestIsHijacked = false;\n\t\n\tvar listeners = {\n\t  watchCount: {},\n\t  digestLength: {}\n\t};\n\t\n\t// Hijack $digest to time it and update data on every digest.\n\tfunction hijackDigest() {\n\t  if (digestIsHijacked) {\n\t    return;\n\t  }\n\t  digestIsHijacked = true;\n\t  var scopePrototype = Object.getPrototypeOf(getRootScope());\n\t  var oldDigest = scopePrototype.$digest;\n\t  scopePrototype.$digest = function $digest() {\n\t    var start = timerNow();\n\t    oldDigest.apply(this, arguments);\n\t    var diff = timerNow() - start;\n\t    updateData(getWatcherCount(), diff);\n\t  };\n\t}\n\t\n\t// used to prevent localstorage error in chrome packaged apps\n\tfunction isChromeApp() {\n\t  return typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined' && typeof chrome.storage.local !== 'undefined';\n\t}\n\t\n\t// check for autoload\n\tvar autoloadOptions = sessionStorage[autoloadKey] || !isChromeApp() && localStorage[autoloadKey];\n\tif (autoloadOptions) {\n\t  autoload(JSON.parse(autoloadOptions));\n\t}\n\t\n\tfunction autoload(options) {\n\t  if (window.self.angular && getRootScope()) {\n\t    showAngularStats(options);\n\t  } else {\n\t    // wait for angular to load...\n\t    window.self.setTimeout(function () {\n\t      autoload(options);\n\t    }, 200);\n\t  }\n\t}\n\t\n\tfunction showAngularStats(opts) {\n\t  /* eslint max-statements:[2, 43] */\n\t  /* eslint complexity:[2, 18] */\n\t  /* eslint consistent-return:0 */\n\t  // TODO ^^ fix these things...\n\t  opts = opts !== undefined ? opts : {};\n\t  var returnData = {\n\t    listeners: listeners\n\t  };\n\t  // delete the previous one\n\t  if (current) {\n\t    current.$el && current.$el.remove();\n\t    current.active = false;\n\t    current = null;\n\t  }\n\t\n\t  // Remove autoload if they did not specifically request it\n\t  if (opts === false || !opts.autoload) {\n\t    sessionStorage.removeItem(autoloadKey);\n\t    localStorage.removeItem(autoloadKey);\n\t    // do nothing if the argument is false\n\t    if (opts === false) {\n\t      return;\n\t    }\n\t  }\n\t\n\t  opts.position = opts.position || 'top-left';\n\t  opts = angular.extend({\n\t    htmlId: null,\n\t    digestTimeThreshold: 16,\n\t    autoload: false,\n\t    trackDigest: false,\n\t    trackWatches: false,\n\t    logDigest: false,\n\t    logWatches: false,\n\t    styles: {\n\t      position: 'fixed',\n\t      background: 'black',\n\t      borderBottom: '1px solid #666',\n\t      borderRight: '1px solid #666',\n\t      color: 'red',\n\t      fontFamily: 'Courier',\n\t      width: 130,\n\t      zIndex: 9999,\n\t      textAlign: 'right',\n\t      top: opts.position.indexOf('top') === -1 ? null : 0,\n\t      bottom: opts.position.indexOf('bottom') === -1 ? null : 0,\n\t      right: opts.position.indexOf('right') === -1 ? null : 0,\n\t      left: opts.position.indexOf('left') === -1 ? null : 0\n\t    }\n\t  }, opts || {});\n\t\n\t  hijackDigest();\n\t\n\t  // setup the state\n\t  var state = current = { active: true };\n\t\n\t  // auto-load on startup\n\t  if (opts.autoload) {\n\t    if (opts.autoload === 'localStorage') {\n\t      localStorage.setItem(autoloadKey, JSON.stringify(opts));\n\t    } else if (opts.autoload === 'sessionStorage' || typeof opts.autoload === 'boolean') {\n\t      sessionStorage.setItem(autoloadKey, JSON.stringify(opts));\n\t    } else {\n\t      throw new Error('Invalid value for autoload: ' + opts.autoload + ' can only be \"localStorage\" \"sessionStorage\" or boolean.');\n\t    }\n\t  }\n\t\n\t  // general variables\n\t  var bodyEl = angular.element(document.body);\n\t  var noDigestSteps = 0;\n\t\n\t  // add the DOM element\n\t  var htmlId = opts.htmlId ? ' id=\"' + opts.htmlId + '\"' : '';\n\t  state.$el = angular.element('<div' + htmlId + '><canvas></canvas><div></div></div>').css(opts.styles);\n\t  bodyEl.append(state.$el);\n\t  var $text = state.$el.find('div');\n\t\n\t  // initialize the canvas\n\t  var graphSz = { width: 130, height: 40 };\n\t  var cvs = state.$el.find('canvas').attr(graphSz)[0];\n\t\n\t  // add listeners\n\t  listeners.digestLength.ngStatsAddToCanvas = function (digestLength) {\n\t    addDataToCanvas(null, digestLength);\n\t  };\n\t\n\t  listeners.watchCount.ngStatsAddToCanvas = function (watchCount) {\n\t    addDataToCanvas(watchCount);\n\t  };\n\t\n\t  track('digest', listeners.digestLength);\n\t  track('watches', listeners.watchCount, true);\n\t\n\t  log('digest', listeners.digestLength);\n\t  log('watches', listeners.watchCount, true);\n\t\n\t  function track(thingToTrack, listenerCollection, diffOnly) {\n\t    var capThingToTrack = thingToTrack.charAt(0).toUpperCase() + thingToTrack.slice(1);\n\t    if (opts['track' + capThingToTrack]) {\n\t      returnData[thingToTrack] = [];\n\t      listenerCollection['track + capThingToTrack'] = function (tracked) {\n\t        if (!diffOnly || returnData[thingToTrack][returnData.length - 1] !== tracked) {\n\t          returnData[thingToTrack][returnData.length - 1] = tracked;\n\t          returnData[thingToTrack].push(tracked);\n\t        }\n\t      };\n\t    }\n\t  }\n\t\n\t  function log(thingToLog, listenerCollection, diffOnly) {\n\t    var capThingToLog = thingToLog.charAt(0).toUpperCase() + thingToLog.slice(1);\n\t    if (opts['log' + capThingToLog]) {\n\t      var last;\n\t      listenerCollection['log' + capThingToLog] = function (tracked) {\n\t        if (!diffOnly || last !== tracked) {\n\t          last = tracked;\n\t          var color = colorLog(thingToLog, tracked);\n\t          if (color) {\n\t            console.log('%c' + thingToLog + ':', color, tracked);\n\t          } else {\n\t            console.log(thingToLog + ':', tracked);\n\t          }\n\t        }\n\t      };\n\t    }\n\t  }\n\t\n\t  function colorLog(thingToLog, tracked) {\n\t    var color;\n\t    if (thingToLog === 'digest') {\n\t      color = tracked > opts.digestTimeThreshold ? 'color:red' : 'color:green';\n\t    }\n\t    return color;\n\t  }\n\t\n\t  function addDataToCanvas(watchCount, digestLength) {\n\t    var averageDigest = digestLength || lastDigestLength;\n\t    var color = averageDigest > opts.digestTimeThreshold ? 'red' : 'green';\n\t    lastWatchCount = nullOrUndef(watchCount) ? lastWatchCount : watchCount;\n\t    lastDigestLength = nullOrUndef(digestLength) ? lastDigestLength : digestLength;\n\t    $text.text(lastWatchCount + ' | ' + lastDigestLength.toFixed(2)).css({ color: color });\n\t\n\t    if (!digestLength) {\n\t      return;\n\t    }\n\t\n\t    // color the sliver if this is the first step\n\t    var ctx = cvs.getContext('2d');\n\t    if (noDigestSteps > 0) {\n\t      noDigestSteps = 0;\n\t      ctx.fillStyle = '#333';\n\t      ctx.fillRect(graphSz.width - 1, 0, 1, graphSz.height);\n\t    }\n\t\n\t    // mark the point on the graph\n\t    ctx.fillStyle = color;\n\t    ctx.fillRect(graphSz.width - 1, Math.max(0, graphSz.height - averageDigest), 2, 2);\n\t  }\n\t\n\t  // Shift the canvas to the left.\n\t  function shiftLeft() {\n\t    if (state.active) {\n\t      window.self.setTimeout(shiftLeft, 250);\n\t      var ctx = cvs.getContext('2d');\n\t      var imageData = ctx.getImageData(1, 0, graphSz.width - 1, graphSz.height);\n\t      ctx.putImageData(imageData, 0, 0);\n\t      ctx.fillStyle = noDigestSteps++ > 2 ? 'black' : '#333';\n\t      ctx.fillRect(graphSz.width - 1, 0, 1, graphSz.height);\n\t    }\n\t  }\n\t\n\t  // start everything\n\t  shiftLeft();\n\t  if (!$rootScope.$$phase) {\n\t    $rootScope.$digest();\n\t  }\n\t\n\t  return returnData;\n\t}\n\t\n\tangular.module('angularStats', []).directive('angularStats', function () {\n\t  var index = 1;\n\t  return {\n\t    scope: {\n\t      digestLength: '@',\n\t      watchCount: '@',\n\t      watchCountRoot: '@',\n\t      onDigestLengthUpdate: '&?',\n\t      onWatchCountUpdate: '&?'\n\t    },\n\t    link: function link(scope, el, attrs) {\n\t      hijackDigest();\n\t      var directiveIndex = index++;\n\t\n\t      setupDigestLengthElement();\n\t      setupWatchCountElement();\n\t      addWatchCountListener();\n\t      addDigestLengthListener();\n\t      scope.$on('$destroy', destroyListeners);\n\t\n\t      function setupDigestLengthElement() {\n\t        if (attrs.hasOwnProperty('digestLength')) {\n\t          var digestEl = el;\n\t          if (attrs.digestLength) {\n\t            digestEl = angular.element(el[0].querySelector(attrs.digestLength));\n\t          }\n\t          listeners.digestLength['ngStatsDirective' + directiveIndex] = function (length) {\n\t            window.dirDigestNode = digestEl[0];\n\t            digestEl.text((length || 0).toFixed(2));\n\t          };\n\t        }\n\t      }\n\t\n\t      function setupWatchCountElement() {\n\t        if (attrs.hasOwnProperty('watchCount')) {\n\t          var watchCountRoot;\n\t          var watchCountEl = el;\n\t          if (scope.watchCount) {\n\t            watchCountEl = angular.element(el[0].querySelector(attrs.watchCount));\n\t          }\n\t\n\t          if (scope.watchCountRoot) {\n\t            if (scope.watchCountRoot === 'this') {\n\t              watchCountRoot = el;\n\t            } else {\n\t              // In the case this directive is being compiled and it's not in the dom,\n\t              // we're going to do the find from the root of what we have...\n\t              var rootParent;\n\t              if (attrs.hasOwnProperty('watchCountOfChild')) {\n\t                rootParent = el[0];\n\t              } else {\n\t                rootParent = findRootOfElement(el);\n\t              }\n\t              watchCountRoot = angular.element(rootParent.querySelector(scope.watchCountRoot));\n\t              if (!watchCountRoot.length) {\n\t                throw new Error('no element at selector: ' + scope.watchCountRoot);\n\t              }\n\t            }\n\t          }\n\t\n\t          listeners.watchCount['ngStatsDirective' + directiveIndex] = function (count) {\n\t            var watchCount = count;\n\t            if (watchCountRoot) {\n\t              watchCount = getWatcherCountForElement(watchCountRoot);\n\t            }\n\t            watchCountEl.text(watchCount);\n\t          };\n\t        }\n\t      }\n\t\n\t      function addWatchCountListener() {\n\t        if (attrs.hasOwnProperty('onWatchCountUpdate')) {\n\t          listeners.watchCount['ngStatsDirectiveUpdate' + directiveIndex] = function (count) {\n\t            scope.onWatchCountUpdate({ watchCount: count });\n\t          };\n\t        }\n\t      }\n\t\n\t      function addDigestLengthListener() {\n\t        if (attrs.hasOwnProperty('onDigestLengthUpdate')) {\n\t          listeners.digestLength['ngStatsDirectiveUpdate' + directiveIndex] = function (length) {\n\t            scope.onDigestLengthUpdate({ digestLength: length });\n\t          };\n\t        }\n\t      }\n\t\n\t      function destroyListeners() {\n\t        delete listeners.digestLength['ngStatsDirectiveUpdate' + directiveIndex];\n\t        delete listeners.watchCount['ngStatsDirectiveUpdate' + directiveIndex];\n\t        delete listeners.digestLength['ngStatsDirective' + directiveIndex];\n\t        delete listeners.watchCount['ngStatsDirective' + directiveIndex];\n\t      }\n\t    }\n\t  };\n\t\n\t  function findRootOfElement(el) {\n\t    var parent = el[0];\n\t    while (parent.parentElement) {\n\t      parent = parent.parentElement;\n\t    }\n\t    return parent;\n\t  }\n\t});\n\t\n\t// UTILITY FUNCTIONS\n\t\n\tfunction getRootScope() {\n\t  if ($rootScope) {\n\t    return $rootScope;\n\t  }\n\t  var scopeEl = document.querySelector('.ng-scope');\n\t  if (!scopeEl) {\n\t    return null;\n\t  }\n\t  $rootScope = angular.element(scopeEl).scope().$root;\n\t  return $rootScope;\n\t}\n\t\n\t// Uses timeouts to ensure that this is only run every 300ms (it's a perf bottleneck)\n\tfunction getWatcherCount() {\n\t  window.self.clearTimeout(watchCountTimeout);\n\t  var now = timerNow();\n\t  if (now - lastWatchCountRun > 300) {\n\t    lastWatchCountRun = now;\n\t    lastWatchCount = getWatcherCountForScope();\n\t  } else {\n\t    watchCountTimeout = window.self.setTimeout(function () {\n\t      updateData(getWatcherCount());\n\t    }, 350);\n\t  }\n\t  return lastWatchCount;\n\t}\n\t\n\tfunction getWatcherCountForElement(element) {\n\t  var startingScope = getClosestChildScope(element);\n\t  return getWatcherCountForScope(startingScope);\n\t}\n\t\n\tfunction getClosestChildScope(element) {\n\t  element = angular.element(element);\n\t  var scope = element.scope();\n\t  if (!scope) {\n\t    element = angular.element(element.querySelector('.ng-scope'));\n\t    scope = element.scope();\n\t  }\n\t  return scope;\n\t}\n\t\n\tfunction getWatchersFromScope(scope) {\n\t  return scope && scope.$$watchers ? scope.$$watchers : [];\n\t}\n\t\n\t// iterate through listeners to call them with the watchCount and digestLength\n\tfunction updateData(watchCount, digestLength) {\n\t  // update the listeners\n\t  if (!nullOrUndef(watchCount)) {\n\t    angular.forEach(listeners.watchCount, function (listener) {\n\t      listener(watchCount);\n\t    });\n\t  }\n\t  if (!nullOrUndef(digestLength)) {\n\t    angular.forEach(listeners.digestLength, function (listener) {\n\t      listener(digestLength);\n\t    });\n\t  }\n\t}\n\t\n\tfunction nullOrUndef(item) {\n\t  return item === null || item === undefined;\n\t}\n\t\n\tfunction getWatcherCountForScope(scope) {\n\t  var count = 0;\n\t  iterateScopes(scope, function (childScope) {\n\t    count += getWatchersFromScope(childScope).length;\n\t  });\n\t  return count;\n\t}\n\t\n\tfunction iterateScopes(currentScope, fn) {\n\t  if (typeof currentScope === 'function') {\n\t    fn = currentScope;\n\t    currentScope = null;\n\t  }\n\t  currentScope = currentScope || getRootScope();\n\t  currentScope = _makeScopeReference(currentScope);\n\t  if (!currentScope) {\n\t    return;\n\t  }\n\t  var ret = fn(currentScope);\n\t  if (ret === false) {\n\t    return ret;\n\t  }\n\t  return iterateChildren(currentScope, fn);\n\t}\n\t\n\tfunction iterateSiblings(start, fn) {\n\t  var ret;\n\t  /* eslint no-extra-boolean-cast:0 */\n\t  while (!!(start = start.$$nextSibling)) {\n\t    ret = fn(start);\n\t    if (ret === false) {\n\t      break;\n\t    }\n\t\n\t    ret = iterateChildren(start, fn);\n\t    if (ret === false) {\n\t      break;\n\t    }\n\t  }\n\t  return ret;\n\t}\n\t\n\tfunction iterateChildren(start, fn) {\n\t  var ret;\n\t  while (!!(start = start.$$childHead)) {\n\t    ret = fn(start);\n\t    if (ret === false) {\n\t      break;\n\t    }\n\t\n\t    ret = iterateSiblings(start, fn);\n\t    if (ret === false) {\n\t      break;\n\t    }\n\t  }\n\t  return ret;\n\t}\n\t\n\tfunction getScopeById(id) {\n\t  var myScope = null;\n\t  iterateScopes(function (scope) {\n\t    if (scope.$id === id) {\n\t      myScope = scope;\n\t      return false;\n\t    }\n\t  });\n\t  return myScope;\n\t}\n\t\n\tfunction _makeScopeReference(scope) {\n\t  if (_isScopeId(scope)) {\n\t    scope = getScopeById(scope);\n\t  }\n\t  return scope;\n\t}\n\t\n\tfunction _isScopeId(scope) {\n\t  return typeof scope === 'string' || typeof scope === 'number';\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** dist/ng-stats.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap eccbefdad40d7144684b\n **/","/* eslint no-console:0 */\nimport ng from 'angular';\n\nlet angular = ng;\n\n/* istanbul ignore next */\nif (!angular.version) {\n  // we're doing this because some versions\n  // of angular don't expose itself correctly\n  angular = window.angular;\n}\n\nexport default showAngularStats;\n\nvar autoloadKey = 'showAngularStats_autoload';\nvar current = null;\n// define the timer function to use based upon whether or not 'performance is available'\nvar timerNow = window.self.performance && window.self.performance.now\n  ? () => window.self.performance.now()\n  : () => Date.now();\n\nvar lastWatchCountRun = timerNow();\nvar watchCountTimeout = null;\nvar lastWatchCount = getWatcherCount() || 0;\nvar lastDigestLength = 0;\n\nvar $rootScope;\n\nvar digestIsHijacked = false;\n\nvar listeners = {\n  watchCount: {},\n  digestLength: {}\n};\n\n// Hijack $digest to time it and update data on every digest.\nfunction hijackDigest() {\n  if (digestIsHijacked) {\n    return;\n  }\n  digestIsHijacked = true;\n  var scopePrototype = Object.getPrototypeOf(getRootScope());\n  var oldDigest = scopePrototype.$digest;\n  scopePrototype.$digest = function $digest() {\n    var start = timerNow();\n    oldDigest.apply(this, arguments);\n    var diff = (timerNow() - start);\n    updateData(getWatcherCount(), diff);\n  };\n}\n\n// used to prevent localstorage error in chrome packaged apps\nfunction isChromeApp() {\n  return (typeof chrome !== 'undefined' &&\n  typeof chrome.storage !== 'undefined' &&\n  typeof chrome.storage.local !== 'undefined');\n}\n\n// check for autoload\nvar autoloadOptions = sessionStorage[autoloadKey] || (!isChromeApp() && localStorage[autoloadKey]);\nif (autoloadOptions) {\n  autoload(JSON.parse(autoloadOptions));\n}\n\nfunction autoload(options) {\n  if (window.self.angular && getRootScope()) {\n    showAngularStats(options);\n  } else {\n    // wait for angular to load...\n    window.self.setTimeout(function() {\n      autoload(options);\n    }, 200);\n  }\n}\n\nfunction showAngularStats(opts) {\n  /* eslint max-statements:[2, 43] */\n  /* eslint complexity:[2, 18] */\n  /* eslint consistent-return:0 */\n  // TODO ^^ fix these things...\n  opts = opts !== undefined ? opts : {};\n  var returnData = {\n    listeners: listeners\n  };\n  // delete the previous one\n  if (current) {\n    current.$el && current.$el.remove();\n    current.active = false;\n    current = null;\n  }\n\n  // Remove autoload if they did not specifically request it\n  if (opts === false || !opts.autoload) {\n    sessionStorage.removeItem(autoloadKey);\n    localStorage.removeItem(autoloadKey);\n    // do nothing if the argument is false\n    if (opts === false) {\n      return;\n    }\n  }\n\n  opts.position = opts.position || 'top-left';\n  opts = angular.extend({\n    htmlId: null,\n    digestTimeThreshold: 16,\n    autoload: false,\n    trackDigest: false,\n    trackWatches: false,\n    logDigest: false,\n    logWatches: false,\n    styles: {\n      position: 'fixed',\n      background: 'black',\n      borderBottom: '1px solid #666',\n      borderRight: '1px solid #666',\n      color: 'red',\n      fontFamily: 'Courier',\n      width: 130,\n      zIndex: 9999,\n      textAlign: 'right',\n      top: opts.position.indexOf('top') === -1 ? null : 0,\n      bottom: opts.position.indexOf('bottom') === -1 ? null : 0,\n      right: opts.position.indexOf('right') === -1 ? null : 0,\n      left: opts.position.indexOf('left') === -1 ? null : 0\n    }\n  }, opts || {});\n\n  hijackDigest();\n\n  // setup the state\n  var state = current = {active: true};\n\n  // auto-load on startup\n  if (opts.autoload) {\n    if (opts.autoload === 'localStorage') {\n      localStorage.setItem(autoloadKey, JSON.stringify(opts));\n    } else if (opts.autoload === 'sessionStorage' || typeof opts.autoload === 'boolean') {\n      sessionStorage.setItem(autoloadKey, JSON.stringify(opts));\n    } else {\n      throw new Error(\n        'Invalid value for autoload: ' + opts.autoload + ' can only be \"localStorage\" \"sessionStorage\" or boolean.'\n      );\n    }\n  }\n\n  // general variables\n  var bodyEl = angular.element(document.body);\n  var noDigestSteps = 0;\n\n  // add the DOM element\n  var htmlId = opts.htmlId ? (' id=\"' + opts.htmlId + '\"') : '';\n  state.$el = angular.element('<div' + htmlId + '><canvas></canvas><div></div></div>').css(opts.styles);\n  bodyEl.append(state.$el);\n  var $text = state.$el.find('div');\n\n  // initialize the canvas\n  var graphSz = {width: 130, height: 40};\n  var cvs = state.$el.find('canvas').attr(graphSz)[0];\n\n\n  // add listeners\n  listeners.digestLength.ngStatsAddToCanvas = function(digestLength) {\n    addDataToCanvas(null, digestLength);\n  };\n\n  listeners.watchCount.ngStatsAddToCanvas = function(watchCount) {\n    addDataToCanvas(watchCount);\n  };\n\n  track('digest', listeners.digestLength);\n  track('watches', listeners.watchCount, true);\n\n  log('digest', listeners.digestLength);\n  log('watches', listeners.watchCount, true);\n\n  function track(thingToTrack, listenerCollection, diffOnly) {\n    var capThingToTrack = thingToTrack.charAt(0).toUpperCase() + thingToTrack.slice(1);\n    if (opts['track' + capThingToTrack]) {\n      returnData[thingToTrack] = [];\n      listenerCollection['track + capThingToTrack'] = function(tracked) {\n        if (!diffOnly || returnData[thingToTrack][returnData.length - 1] !== tracked) {\n          returnData[thingToTrack][returnData.length - 1] = tracked;\n          returnData[thingToTrack].push(tracked);\n        }\n      };\n    }\n  }\n\n  function log(thingToLog, listenerCollection, diffOnly) {\n    var capThingToLog = thingToLog.charAt(0).toUpperCase() + thingToLog.slice(1);\n    if (opts['log' + capThingToLog]) {\n      var last;\n      listenerCollection['log' + capThingToLog] = function(tracked) {\n        if (!diffOnly || last !== tracked) {\n          last = tracked;\n          var color = colorLog(thingToLog, tracked);\n          if (color) {\n            console.log('%c' + thingToLog + ':', color, tracked);\n          } else {\n            console.log(thingToLog + ':', tracked);\n          }\n        }\n      };\n    }\n  }\n\n  function colorLog(thingToLog, tracked) {\n    var color;\n    if (thingToLog === 'digest') {\n      color = tracked > opts.digestTimeThreshold ? 'color:red' : 'color:green';\n    }\n    return color;\n  }\n\n  function addDataToCanvas(watchCount, digestLength) {\n    var averageDigest = digestLength || lastDigestLength;\n    var color = (averageDigest > opts.digestTimeThreshold) ? 'red' : 'green';\n    lastWatchCount = nullOrUndef(watchCount) ? lastWatchCount : watchCount;\n    lastDigestLength = nullOrUndef(digestLength) ? lastDigestLength : digestLength;\n    $text.text(lastWatchCount + ' | ' + lastDigestLength.toFixed(2)).css({color: color});\n\n    if (!digestLength) {\n      return;\n    }\n\n    // color the sliver if this is the first step\n    var ctx = cvs.getContext('2d');\n    if (noDigestSteps > 0) {\n      noDigestSteps = 0;\n      ctx.fillStyle = '#333';\n      ctx.fillRect(graphSz.width - 1, 0, 1, graphSz.height);\n    }\n\n    // mark the point on the graph\n    ctx.fillStyle = color;\n    ctx.fillRect(graphSz.width - 1, Math.max(0, graphSz.height - averageDigest), 2, 2);\n  }\n\n  // Shift the canvas to the left.\n  function shiftLeft() {\n    if (state.active) {\n      window.self.setTimeout(shiftLeft, 250);\n      var ctx = cvs.getContext('2d');\n      var imageData = ctx.getImageData(1, 0, graphSz.width - 1, graphSz.height);\n      ctx.putImageData(imageData, 0, 0);\n      ctx.fillStyle = ((noDigestSteps++) > 2) ? 'black' : '#333';\n      ctx.fillRect(graphSz.width - 1, 0, 1, graphSz.height);\n    }\n  }\n\n  // start everything\n  shiftLeft();\n  if (!$rootScope.$$phase) {\n    $rootScope.$digest();\n  }\n\n  return returnData;\n}\n\nangular.module('angularStats', []).directive('angularStats', function() {\n  var index = 1;\n  return {\n    scope: {\n      digestLength: '@',\n      watchCount: '@',\n      watchCountRoot: '@',\n      onDigestLengthUpdate: '&?',\n      onWatchCountUpdate: '&?'\n    },\n    link: function(scope, el, attrs) {\n      hijackDigest();\n      var directiveIndex = index++;\n\n      setupDigestLengthElement();\n      setupWatchCountElement();\n      addWatchCountListener();\n      addDigestLengthListener();\n      scope.$on('$destroy', destroyListeners);\n\n      function setupDigestLengthElement() {\n        if (attrs.hasOwnProperty('digestLength')) {\n          var digestEl = el;\n          if (attrs.digestLength) {\n            digestEl = angular.element(el[0].querySelector(attrs.digestLength));\n          }\n          listeners.digestLength['ngStatsDirective' + directiveIndex] = function(length) {\n            window.dirDigestNode = digestEl[0];\n            digestEl.text((length || 0).toFixed(2));\n          };\n        }\n      }\n\n      function setupWatchCountElement() {\n        if (attrs.hasOwnProperty('watchCount')) {\n          var watchCountRoot;\n          var watchCountEl = el;\n          if (scope.watchCount) {\n            watchCountEl = angular.element(el[0].querySelector(attrs.watchCount));\n          }\n\n          if (scope.watchCountRoot) {\n            if (scope.watchCountRoot === 'this') {\n              watchCountRoot = el;\n            } else {\n              // In the case this directive is being compiled and it's not in the dom,\n              // we're going to do the find from the root of what we have...\n              var rootParent;\n              if (attrs.hasOwnProperty('watchCountOfChild')) {\n                rootParent = el[0];\n              } else {\n                rootParent = findRootOfElement(el);\n              }\n              watchCountRoot = angular.element(rootParent.querySelector(scope.watchCountRoot));\n              if (!watchCountRoot.length) {\n                throw new Error('no element at selector: ' + scope.watchCountRoot);\n              }\n            }\n          }\n\n          listeners.watchCount['ngStatsDirective' + directiveIndex] = function(count) {\n            var watchCount = count;\n            if (watchCountRoot) {\n              watchCount = getWatcherCountForElement(watchCountRoot);\n            }\n            watchCountEl.text(watchCount);\n          };\n        }\n      }\n\n      function addWatchCountListener() {\n        if (attrs.hasOwnProperty('onWatchCountUpdate')) {\n          listeners.watchCount['ngStatsDirectiveUpdate' + directiveIndex] = function(count) {\n            scope.onWatchCountUpdate({watchCount: count});\n          };\n        }\n      }\n\n      function addDigestLengthListener() {\n        if (attrs.hasOwnProperty('onDigestLengthUpdate')) {\n          listeners.digestLength['ngStatsDirectiveUpdate' + directiveIndex] = function(length) {\n            scope.onDigestLengthUpdate({digestLength: length});\n          };\n        }\n      }\n\n      function destroyListeners() {\n        delete listeners.digestLength['ngStatsDirectiveUpdate' + directiveIndex];\n        delete listeners.watchCount['ngStatsDirectiveUpdate' + directiveIndex];\n        delete listeners.digestLength['ngStatsDirective' + directiveIndex];\n        delete listeners.watchCount['ngStatsDirective' + directiveIndex];\n      }\n    }\n  };\n\n  function findRootOfElement(el) {\n    var parent = el[0];\n    while (parent.parentElement) {\n      parent = parent.parentElement;\n    }\n    return parent;\n  }\n});\n\n// UTILITY FUNCTIONS\n\nfunction getRootScope() {\n  if ($rootScope) {\n    return $rootScope;\n  }\n  var scopeEl = document.querySelector('.ng-scope');\n  if (!scopeEl) {\n    return null;\n  }\n  $rootScope = angular.element(scopeEl).scope().$root;\n  return $rootScope;\n}\n\n// Uses timeouts to ensure that this is only run every 300ms (it's a perf bottleneck)\nfunction getWatcherCount() {\n  window.self.clearTimeout(watchCountTimeout);\n  var now = timerNow();\n  if (now - lastWatchCountRun > 300) {\n    lastWatchCountRun = now;\n    lastWatchCount = getWatcherCountForScope();\n  } else {\n    watchCountTimeout = window.self.setTimeout(function() {\n      updateData(getWatcherCount());\n    }, 350);\n  }\n  return lastWatchCount;\n}\n\nfunction getWatcherCountForElement(element) {\n  var startingScope = getClosestChildScope(element);\n  return getWatcherCountForScope(startingScope);\n}\n\nfunction getClosestChildScope(element) {\n  element = angular.element(element);\n  var scope = element.scope();\n  if (!scope) {\n    element = angular.element(element.querySelector('.ng-scope'));\n    scope = element.scope();\n  }\n  return scope;\n}\n\nfunction getWatchersFromScope(scope) {\n  return scope && scope.$$watchers ? scope.$$watchers : [];\n}\n\n// iterate through listeners to call them with the watchCount and digestLength\nfunction updateData(watchCount, digestLength) {\n  // update the listeners\n  if (!nullOrUndef(watchCount)) {\n    angular.forEach(listeners.watchCount, function(listener) {\n      listener(watchCount);\n    });\n  }\n  if (!nullOrUndef(digestLength)) {\n    angular.forEach(listeners.digestLength, function(listener) {\n      listener(digestLength);\n    });\n  }\n}\n\nfunction nullOrUndef(item) {\n  return item === null || item === undefined;\n}\n\nfunction getWatcherCountForScope(scope) {\n  var count = 0;\n  iterateScopes(scope, function(childScope) {\n    count += getWatchersFromScope(childScope).length;\n  });\n  return count;\n}\n\nfunction iterateScopes(currentScope, fn) {\n  if (typeof currentScope === 'function') {\n    fn = currentScope;\n    currentScope = null;\n  }\n  currentScope = currentScope || getRootScope();\n  currentScope = _makeScopeReference(currentScope);\n  if (!currentScope) {\n    return;\n  }\n  var ret = fn(currentScope);\n  if (ret === false) {\n    return ret;\n  }\n  return iterateChildren(currentScope, fn);\n}\n\nfunction iterateSiblings(start, fn) {\n  var ret;\n  /* eslint no-extra-boolean-cast:0 */\n  while (!!(start = start.$$nextSibling)) {\n    ret = fn(start);\n    if (ret === false) {\n      break;\n    }\n\n    ret = iterateChildren(start, fn);\n    if (ret === false) {\n      break;\n    }\n  }\n  return ret;\n}\n\nfunction iterateChildren(start, fn) {\n  var ret;\n  while (!!(start = start.$$childHead)) {\n    ret = fn(start);\n    if (ret === false) {\n      break;\n    }\n\n    ret = iterateSiblings(start, fn);\n    if (ret === false) {\n      break;\n    }\n  }\n  return ret;\n}\n\n\nfunction getScopeById(id) {\n  var myScope = null;\n  iterateScopes(function(scope) {\n    if (scope.$id === id) {\n      myScope = scope;\n      return false;\n    }\n  });\n  return myScope;\n}\n\nfunction _makeScopeReference(scope) {\n  if (_isScopeId(scope)) {\n    scope = getScopeById(scope);\n  }\n  return scope;\n}\n\nfunction _isScopeId(scope) {\n  return typeof scope === 'string' || typeof scope === 'number';\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./index.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"angular\"\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}